---
title: 前端性能优化体系
date: 2021-12-26 09:59:14
permalink: /pages/5637a8/
categories:
  - 技术文档
  - 性能优化
tags:
  - 
---

本文主要从以下 5 点来讲述前端性能优化体系：

1. 性能优化的指标
2. 性能瓶颈点
3. 性能监控平台的建设
4. 性能优化的手段
5. 大厂的性能方案对比

<!-- more -->

## 优化的指标

前端性能优化较琐碎繁杂，为了避免出现头痛医头，脚痛医脚的情况，需要系统性的认识一下前端性能优化体系。做到能够体检预警性能问题，做到有的放矢的优化。

目前在做性能优化的时候最看重的指标是白屏时间、首屏时间、秒开率，三者之中最为重要的是首屏率。

### 白屏时间
指的是从输入内容回车（包括刷新、跳转等方式）后，到页面开始出现第一个字符的时间。这个过程包括 DNS 查询，建立 TCP 连接，发送首个HTTP请求（如果使用HTTPS还要介入 TLS 的验证时间），返回HTML文档，HTML文档 Head 解析完毕。它的标准时间是 300ms。

如果白屏时间过长，用户会认为页面不可用，或者可用性差。如果超过一定时间（如 1s），用户注意力就会转移到其他页面。

### 首屏时间
首屏时间=白屏时间+渲染时间。它是指从浏览器输入地址并回车后，到首屏内容渲染完毕的时间。这期间不需要滚动鼠标或者下拉页面，否则无效。页面渲染完成后保证基本的功能都是可用的。

| 类别 | 快 | 较快 | 慢 | 很慢 | 指标示例 |
| --- | --- | --- | --- | --- | --- |
| 时间敏感 | <1s | 1s~1.5s | 1.5s~2.5s | >2.5s | 首屏、白屏 |
| 时间不敏感 | <2s | 2s~4s | 4s~8s | >8s | onload |
| 最佳：白屏<1s, 首屏<1.5s, onload<3s |  |  |  |  |  |



### 秒开率
分位值处理起来还是比较麻烦，为了计算简单，便于理解，引入秒开率指标，即 1s 内打开用户的占比。这个概念最早来自阿里巴巴，后来被业界普遍采用。


| 类型 | 首屏时间 | 秒开率 | 1.5秒开率 | 2秒开率 |
| --- | --- | --- | --- | --- |
| SSR | 1000ms | 80% | 95% | 98% |
| 端内 | 1200ms | 65% | 85% | 90% |
| 端外 | 1500ms | 40% | 60% | 80% |


## 性能瓶颈点

分析页面加载全过程，通过这个过程，找到其中影响性能的关键点、瓶颈点，做到有的放矢。
浏览器输入 URL 并回车后：
1. 浏览器向 DNS 服务器发起 DNS 查询，将 URL 解析成IP
2. 获取 IP 地址。然后浏览器通过 IP 地址找到目标服务器，发起 TCP 三次握手和 TLS 协商建立 TCP 连接
3. 发起 HTTP 请求，而服务端接收到后，对请求进行响应。
4. 浏览器从响应结果中拿到数据，并进行解析和渲染，最后在用户面前就出现了一个网页。

大致可以分为三个阶段：
1. 发起请求阶段
2. 服务端数据处理请求阶段
3. 页面渲染阶段

### 发起请求阶段
用户输入 URL，经过本地缓存确认是否已经存在这个网站，如果没有，接着会由 DNS 查询从域名服务器获取这个 IP 地址，接下来就是客户端通过 TCP 的三次握手和TLS协商向服务器发起 HTTP 请求建立连接的过程。

在这个过程中，本地缓存、DNS查询、HTTP 请求很容易成为影响前端性能的瓶颈点。

#### 实现 http 本地缓存
本地缓存一般包括强缓存和协商缓存两种形式。
+ 强缓存：是指浏览器在加载资源时，根据请求头的 expires 和 cache-control 判断是否命中客户端缓存。如果命中，则直接从缓存读取资源，不会发请求到服务器，反之还需要走完整的资源请求流程。
+ 协商缓存：是指浏览器会先发送一个请求到服务器，通过 last-modified 和 etag 验证资源是否命中客户端缓存。如果命中，服务器会将这个请求返回，但不会返回这个资源的数据，依然是从缓存中读取资源。 如果没有命中，无论是资源过期或者没有相关资源，都需要向服务器发起请求，等待服务器返回这个资源。

#### DNS 查询
DNS 之所以会成为前端性能瓶颈点，是因为每进行一次 DNS 查询，都要经历从手机到移动信号塔，再到认证 DNS 服务器的过程。这中间需要很长的时间。但用户是不想等待的。

想要节省时间，一个办法就是让 DNS 查询走缓存。幸好浏览器提供了 DNS 预获取的接口，可以在打开浏览器或者 WebView 的同时就进行配置。这样真正请求时，DNS 域名解析可以检查一下浏览器缓存，一旦缓存命中，就不需要去 DNS 服务器查询了。

#### HTTP 请求
在 HTTP 请求阶段，最大的瓶颈点来源于请求阻塞。所谓请求阻塞，就是浏览器为保证访问速度，会默认对同一域下的资源保持一定的连接数，请求过多就会进行阻塞。
浏览器同域名的连接数限制：一般是 6 个。如果当前请求书多于 6 个，只能 6 个并发，其余的得等最先返回的请求后，才能做下一次请求。

域名规划
在项目之初，做一些域名规划很重要。先看看当前页面需要用到哪些域名，最关键的首屏中需要用到哪些域名，规划这些域名发送的顺序。

域名散列
除了域名规划，为了解决同域名下的阻塞问题，还可以做域名散列，通过不同的域名，增加请求并行连接数。常见做法是，将静态服务器地址 pic.google.com，做成支持 pic0-5 的 6 个域名，每次请求时随机选一个域名地址进行请求。因为有 6 个域名同时可用，最多可以并行 36 个连接。当然，这个域名个数不是越多越好，太分散的话，又会涉及多域名之间无法缓存的问题。


### 服务端数据处理阶段的瓶颈点

服务端程序接收到 HTTP 请求后，会做一些请求参数处理以及权限校验。校验完成后，它会将请求参数发送到数据存储服务。然后服务端程序会从数据存储中取到数据，进行数据加工聚合处理，最后再通过 jsonp 或者 ajax 接口返回给前端。

这个过程中的瓶颈点，就在于是否做了

1. 数据缓存处理
2. Gzip 压缩
3. 重定向。

+ Service Worker：是浏览器的一个高级属性，本质上是一个请求代理层，它存在的目的就是拦截和处理网络数据请求。如果没有 Service Worker，请求每次直接落到 WebServer 上，需要走一次后端数据存取链路的流程，这会延长页面打开时间。
+ 借助本次存储的接口缓存是指，在一些对数据时效性要求不高的页面，第一次请求到数据后，程序将数据存储到本地存储（store 或者 localStorage、甚至客户端本身的存储），下一次请求的时候，先去缓存里面取将取数据，如果没有的话，再向服务器发起请求。
+ 所谓 CDN，它的基本思路是，通过在网络各处放置节点服务器，构造一个智能虚拟网络，将用户的请求导向离用户最近的服务节点上

#### Gzip
其中，Gzip 压缩是一种压缩技术，服务器端通过使用 Gzip，传输到浏览器端的文本类资源（有别于图片等二进制等资源）的大小可以变为原来的 1/3 左右。因此通过 Gzip 压缩，资源的下载速度会快很多，能大大提升页面的展示速度。

因为多数情况下，运维团队都会默认开启 Gzip 压缩。

#### 重定向
重定向指网站资源（如表单，整个站点等）迁移到其他位置后，用户访问站点时，程序自动将用户请求从一个页面转移到另外一个页面的过程。

在服务端处理阶段，重定向分为三类：
1. 服务端发挥的302重定向
2. META 标签实现的重定向
3. 前端 Javasript 通过window.location 实现的重定向。

它们都会引发新的 DNS 查询，导致新的 TCP 三次握手和 TLS 协商，以及产生新的 HTTP 请求。而这些都会导致请求过程中更多的时间，进而影响前端性能。所以重定向也是一个需要注意的性能瓶颈点，在优化的时候需要注意。

### 页面解析和渲染阶段的瓶颈点

解析，就是 HTML 解析器把页面内容转换为 DOM 树和 CSSOM树的过程。

1. HTML 解析器通过词法分析获得开始和结束标签，生成相应的节点和创建节点之间的父子关系结构，直到完成 DOM 树的创建
2. HTML 解析器遇到内联的 style 标签时，会触发 CSS 解析器对样式内容进行解析，与上面解析器解析 HTML 过程类似，CSS 解析器遍历其中每个规则，将 CSS 规则解析浏览器可解析和处理的样式集合，最终结合浏览器里面的默认样式，汇总形成具有父子关系的 CSSOM 树。
3. 解析完后就是渲染。主线程会计算 DOM 节点的最终样式，生成布局树。布局树会记录参与页面布局的节点和样式。完成布局后，紧跟着就是绘制。绘制就是把各个节点绘制到屏幕上的过程，绘制结果以层的方式保存。当文档中各个部分以不同的层绘制时，相互重叠时，就必须进行合成，以确保他们可以以正确的顺序绘制和展示。

解析和渲染阶段环节多，逻辑复杂，瓶颈点也多：
1. DOM 树构建过程
2. CSSOM 树生成阶段
3. 重排和重绘过程等 

#### 构建 DOM 树的瓶颈点
解析器构建 DOM 树的过程中，有三点会严重影响前端性能。
1. 一个是当 HTML 标签不满足 Web 语义化时，浏览器就需要更多时间去解析 DOM 标签的含义。特别解析器是对标签的容错，比如将 `<br>` 写成了 `</br>`，又或者表格嵌套不标准，标签层次结构复杂等。遇到这些情况时，浏览器会进行语法纠错。这就会导致页面总的解析和渲染阶段需要更长的时间，严重影响页面展示性能。
2. 另一个是 DOM 节点的数量越多，构建 DOM 树的时间就会变长，进而延长解析时间，拖慢页面展示速度。
3. 最后一个是文档中包含`<SCRIPT>` 标签时的情况。因为无论是 DOM 或者 CSSOM 都可以被 JavaScript 所访问并修改，所以一旦在页面解析时遇到 `<SCRIPT>` 标签，DOM 的构造过程就会暂停，等待服务器请求脚本。在脚本加载完成后，还要等取回所有的 CSS 及完成 CSSOM 之后才继续执行。这个过程中用户看到的是白色的屏幕。因此外部 `<SCRIPT>` 常被称为“解析”阶段的拦路虎。有时就因为解析过程中多了一个 `<SCRIPT>`，造成页面解析阶段从 200ms 变为 1s。

#### 布局中的瓶颈点
在布局阶段，浏览器会根据样式解析器给出的样式规则，来计算某个元素需要占据的空间大小和屏幕中的位置（比如电商详情页一张 banner图片的高度、宽度和位置），借助结算结果，来进行布局。而主线程布局时，使用的是流模型的布局方式。所谓流模型，就是像水流一样，需要从左到右，从上到下遍历一遍所有元素。

假设我们在页面渲染过程运行时修改了一个元素的属性，比如在电商的商品详情页加入一条广告数据。这时布局阶段受到了影响。浏览器必须检查所有其他区域的元素，然后自动重排页面，受到影响的元素需要重新绘制，最后还得合成，相当于整个渲染流程再来了一遍。

除此之外，因为浏览器每次布局计算都要作用于整个 DOM，如果元素量大，计算出所有元素的位置和尺寸会花很长的时间。所以布局阶段很容易成为性能瓶颈点。

## 性能监控平台的建设
在确定了优化指标和有可能的性能瓶颈后就需要搭建性能监控平台了，前端性能平台可是性能优化体系当中最核心的环节。

前端性能监控平台包括：
1. 性能优化指标采集上报 SDK
2. 性能数据处理后台，数据入库、数据清洗、数据计算
3. 性能数据展示前台

### 性能优化指标采集上报 SDK

### 性能数据处理后台
1. SDK 上报性能数据指标后，利用 Controller 层对数据做处理。  
  a. 为了避免数据库出现“脏数据”（如空数据、异常数据），影响后续数据处理，将 SDK 上报的数据通过 URL 解析成 key-value 格式的数据，对数据进行空数据删除，异常数据舍弃等操作。  
  b. 然后让数据写进消息队列 Kafka。

为什么不是直接存入 Hive 呢？
客户端上报的性能数据量和用户规模有关。如果直接入库到 Hive，遇到高并发的时候，会因为服务器扛不住而导致数据丢失。与此同时，因为数据下游（数据的使用方，如数据清洗计算平台，性能预警模块）会有多个数据接收端，直接入库的话也会造成数据重复。

2. 第二步，对 Kafka 中的数据，做数据清洗和数据计算。数据清洗，是指针对性能上报单条数据进行核对校验的过程。所清洗的数据包括：

+ 对重复数据的处理，即同一个用户网络出错时，多次重试导致上传了好几条首屏时间相关的数据；

+ 对缺失数据的处理，虽然上报了首屏时间，但白屏时间或者卡顿时间计算时没能给出；

对错误数据的处理，即数据超出正常范围，出现负值或者超出极大值的情况。

这几种类型数据问题如果不处理，最终会影响计算结果的准确性。那么该怎么处理呢？

遇到重复数据，直接去重删除即可。

遇到缺失数据，我们在 Spark 平台上，先根据上报的 Performance 数据进行计算补全，如果无法补全的，就直接舍弃掉，不然会出现后续无法入库的情况。

遇到超出正常范围的数据，如负值或者超过 10 秒以上的数据，把它当作无效数据，直接舍弃掉。

做完数据清洗之后，我们还需要使用 Spark 做数据计算，为可视化展现准备数据。具体需要做以下数据计算：

首屏时间分布的计算，1s ～ 2s 占比多少，2s ～ 4s 占比多少；

秒开率的计算，首屏时间小于等于 1 秒的数据占比；

页面瀑布流时间的计算。


3. 借助 Hive 提供的接口，数据计算层使用 SQL 语句从 Hive 拉取计算后的数据到数据库平台（MongoDB），平台层取出数据，准备数据可视化展现的数据。

### 性能数据展示前台

