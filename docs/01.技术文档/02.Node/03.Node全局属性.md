---
title: Node全局属性
date: 2021-08-06 11:28:11
permalink: /pages/d20b6a/
categories:
  - 技术文档
  - Node
tags:
  - Node
  - 全栈
---

## 全局对象
node与浏览器平台 window 不完全相同,node 全局对象是挂载了许多属性

### global
- global 是全局对象，是全局变量的宿主
- 不是所有全局变量都在 global 中
  node 版本不同，global 暴露的信息不同
  不暴露的为不可枚举类型，想看可以将 global 中属性变成枚举类型，或切换版本

### 常见全局变量

可以这么想，在弄的中每个文件就是一个模块，在 node 运行的时候会为其注入和全局对象

- \_\_filename: 返回正在执行脚本文件的绝对路径
- \_\_dirname: 返回正在执行脚本所在目录
- timer 类函数：执行顺序与事件循环间的关系
- process：提供与当前进程互动的接口
- require： 实现模块的加载
- module、exports：处理模块的导出

<!-- more -->

### this

和浏览器平台下不同的时 this 默认情况下时空对象，和 global 并不是一样的

```javascript
console.log(this === global) // false
console.log(this)(
  // {}

  function() {
    console.log(this === global) // true
  }
)
```

### 为什么 第一个 this 不等于 global， 函数中的 this 为 global？

**问题：**

- var a = this;中的 this 是一个空对象，而函数中的 this 语句是 node.js 全局对象的阴影。我知道 this 关键字在函数上是不同的，但我不明白为什么第一个 this 不等于 global，而函数中的 this 等于 global。
- this 是指向调用该 function 的对象，比如你的 function 在全局下，则 this 就指向 global 了。在浏览器里即 window
- node.js 如何在函数作用域中将 global 注入 this，为什么不注入模块作用域？
  **基本事实：**
- 在节点模块的顶层代码中，this 相当于 module.exports。那是你看到的空物体。
- 在函数内部使用 this 时，this 的值在函数每次执行之前都会重新确定，其值由函数的执行方式决定。这意味着，如果调用机制不同(例如，aFunction()与 aFunction.call(newThis)与 emitter.addEventListener("someEvent", aFunction);等)，则完全相同的函数对象的两个调用可能具有不同的 this 值。在这种情况下，aFunction()在非严格模式下运行的函数 this 设置为全局对象。
- 当 javascript 文件作为节点模块被 required 时，节点引擎在包装器函数内部运行模块代码。调用该模块包装函数时，this 设置为 module.exports。(回想一下，上面的函数可以使用 abitrary this 值运行。)
  因此，您得到不同的 this 值，因为每个 this 都位于不同的函数中：第一个位于节点创建的模块包装函数的内部，第二个位于 aFunction 的内部。

### node 模块

node.js 实际上是将模块代码包装到一个函数中

```javascript
;(function(exports, require, module, __filename, __dirname) {
  var test = function() {
    console.log(`From test: ` + this)
  }
  console.log(this)
  test()
})
```

被包装的函数实际上是这样调用的

```javascript
var args = [self.exports, require, self, filename, dirname]
return compiledWrapper.apply(self.exports, args)
```

因此，在模块级，this 实际上是 exports 对象。
可以这样确认

```javascript
console.log(this, this === module.exports)
// {} true
```

## 全局变量 process

### process.memoryUsage()

process.memoryUsage() 方法会返回描述 Node.js 进程的内存使用情况（以字节为单位）的对象。

```javascript
console.log(process.memoryUsage())
```

```javascript
{
  rss: 4935680,
  heapTotal: 1826816,
  heapUsed: 650472,
  external: 49879,
  arrayBuffers: 9386
}
```

- heapTotal 和 heapUsed 代表 V8 的内存使用情况。
- external 代表 V8 管理的绑定到 Javascript 对象的 C++ 对象的内存使用情况。
- rss，常驻集大小, 是为进程分配的物理内存（总分配内存的子集）的大小，包括所有的 C++ 和 JavaScript 对象与代码。
- arrayBuffers 代表分配给 ArrayBuffer 和 SharedArrayBuffer 的内存，包括所有的 Node.js Buffer。 这也包含在 external 值中。

:::tip
当 Node.js 被用作嵌入式库时，此值可能为 0，因为在这种情况下可能无法跟踪 ArrayBuffer 的分配。  
当使用 Worker 线程时， rss 会是对整个进程都有效的值，而其他字段只代表当前线程。
:::

### process.cpuUsage()

process.cpuUsage() 方法返回包含当前进程的用户 CPU 时间和系统 CPU 时间的对象。 此对象包含 user 和 system 属性，属性值的单位都是微秒（百万分之一秒）。 用户和系统的属性值分别计算了执行用户程序和系统程序的时间，如果此进程在执行任务时是基于多核 CPU，值可能比实际花费的时间要大。  
上一次调用 process.cpuUsage() 方法的结果，可以作为参数值传递给此方法，得到的结果是与上一次的差值。

```javascript
const startUsage = process.cpuUsage()
// { user: 38579, system: 6986 }

// 将 CPU 旋转 500 毫秒。
const now = Date.now()
while (Date.now() - now < 500);

console.log(process.cpuUsage(startUsage))
// { user: 514883, system: 11226 }
```

### process.cwd()

返回当前进程的目录
process.cwd() 方法返回 Node.js 进程的当前工作目录。

### process.version

当前 node 版本

### process.arch

编译 Node.js 二进制文件的操作系统的 CPU 架构。 可能的值有：`arm`、 `arm64`、 `ia32`、 `mips`、 `mipsel`、 `ppc`、 `ppc64`、 `s390`、 `s390x`、 `x32` 和 `x64`。

### process.env

process.env 属性会返回包含用户环境的对象。

```shell
{
  TERM: `xterm-256color`,
  SHELL: `/usr/local/bin/bash`,
  USER: `nodejscn`,
  PATH: `~/.bin/:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin`,
  PWD: `/Users/nodejscn`,
  EDITOR: `vim`,
  SHLVL: `1`,
  HOME: `/Users/nodejscn`,
  LOGNAME: `nodejscn`,
  _: `/usr/local/bin/node`
}
```

可以修改此对象，但这些修改不会反映到 Node.js 进程之外，或者（除非明确地要求）反映到其他 Worker 线程。 换句话说，以下示例不会起作用：

```shell
$ node -e `process.env.foo = "bar"` && echo $foo
```

以下示例则会起作用：

```javascript
process.env.foo = `bar`
console.log(process.env.foo)
```

在 process.env 上为属性赋值会隐式地将值转换为字符串。 不推荐使用此行为。 当值不是字符串、数字或布尔值时，Node.js 未来的版本可能会抛出错误。

```javascript
process.env.test = null
console.log(process.env.test)
// => `null`
process.env.test = undefined
console.log(process.env.test)
// => `undefined`
```

使用 delete 可以从 process.env 中删除属性。
```javascript
process.env.TEST = 1;
delete process.env.TEST;
console.log(process.env.TEST);
// => undefined
```
在 Windows 操作系统上，环境变量不区分大小写。
```javascript
process.env.TEST = 1;
console.log(process.env.test);
// => 1
```

:::tips
除非在创建 Worker 实例时显式地指定，否则每个 Worker 线程都有自己的 process.env 副本（基于其父线程的 process.env，或者指定为 Worker 构造函数的 env 选项的任何内容）。 对于 process.env 的更改在 Worker 线程中是不可见的，并且只有主线程可以做出对操作系统或原生插件可见的更改。
:::

### process.platform
process.platform 属性会返回标识操作系统平台（Node.js 进程运行其上的）的字符串。
当前可能的值有：
+ `aix`  
+ `darwin` 
+ `freebsd` 
+ `linux` 
+ `openbsd` 
+ `sunos` 
+ `win32` 
如果 Node.js 构建于 Android 操作系统上，则也可能返回值为 `android`。 但是，Node.js 中的 Android 支持是实验性的。

### process.argv
+ <string[]>
process.argv 属性会返回一个数组，其中包含当 Node.js 进程被启动时传入的命令行参数。 第一个元素是 process.execPath。 如果需要访问 argv[0] 的原始值，则参见 process.argv0。 第二个元素是正被执行的 JavaScript 文件的路径。 其余的元素是任何额外的命令行参数。
例如，假设 process-args.js 的脚本如下：
```javascript
// 打印 process.argv。
process.argv.forEach((val, index) => {
  console.log(`${index}: ${val}`);
});
```
启动 Node.js 进程：
```shell
$ node process-args.js 参数1 参数2 参数3
```
输出如下：
```shell
0: /usr/local/bin/node
1: /Users/mjr/work/node/process-args.js
2: 参数1
3: 参数2
4: 参数3
```

## 一个字等于多少个字节
   一个字等于多少个字节，与系统硬件（总线、cpu命令字位数等）有关，不应该毫无前提地说一个字等于多少位。
正确的说法：
1. 1字节（byte） = 8位（bit）  
2. 在16位的系统中（比如8086微机） 1字 （word）= 2字节（byte）= 16（bit）  
3. 在32位的系统中（比如win32） 1字（word）= 4字节（byte）=32（bit）  
4. 在64位的系统中（比如win64）1字（word）= 8字节（byte）=64（bit）  